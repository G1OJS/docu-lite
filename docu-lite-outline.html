<!DOCTYPE html><html lang='en'>
<head>
<title>docu-lite-outline.html</title><link rel='stylesheet' href='./docu-lite-style.css' /><body>
<span class = 'filename'>docu-lite.py</span><br><details open><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>    This is a demo of docu-lite semi-automatic documentation, using this same
    file as the input test case. To try it on your own files,
    change these lines below:
        input_folder = &quot;&quot;
        output_name = &quot;docu-lite-demo-outline.html&quot;
        style_sheet = &quot;docu-lite-style.css&quot;
    Remember that if you use a path containing &quot;\&quot;, you&#x27;ll need to escape them by
    adding another &quot;\&quot; e.g. input_folder = &quot;C:\\users\\me\\mydocs\\test.py&quot;
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>import html
import glob
import os
import argparse

</pre>
</details>
<details><summary><span class ='def signature'>def parse_args():</span></summary>
<pre class ='def content'>    parser = argparse.ArgumentParser(description=&quot;Generate an HTML doc outline from source code.&quot;)
    parser.add_argument(&quot;-i&quot;, &quot;--input&quot;, nargs=&quot;*&quot;, default=&quot;./*.py&quot;,
                        help=&quot;Input filenames (default: ./*.py)&quot;)
    parser.add_argument(&quot;-o&quot;, &quot;--output&quot;, default=&quot;docu-lite-outline.html&quot;,
                        help=&quot;Output HTML file (default: docu-lite-outline.html)&quot;)
    parser.add_argument(&quot;-s&quot;, &quot;--style&quot;, default=&quot;docu-lite-style.css&quot;,
                        help=&quot;Output CSS file (default: docu-lite-style.css)&quot;)
    return parser.parse_args()

</pre>
</details>
<details><summary><span class ='class signature'>class docobj:</span></summary>
<details><summary><span class ='def signature'>def __init__(self, signature):</span></summary>
<pre class ='def content'>        self.signature = signature.strip()
        self.object_type = self.signature.split(&quot; &quot;)[0]
        self.docstring =[]
        self.content_start = 0
        self.content_end = 0
        self.indent_spaces = len(signature) - len(signature.lstrip())
        self.indent_level = 0

</pre>
</details>
</details>
<details><summary><span class ='def signature'>def get_doc_objects(lines, object_signatures = ['class','def','docstring','body']):</span></summary>
<details open><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>            document-level properties
            converts document into set of docobj in self.objects
            &#x27;docstring&#x27;,&#x27;text&#x27; represent the opening and closing docstring quotes 
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        objects = []
        indent_level = 0
        indent_spaces = 0

        # replace all opening docstring markers with &#x27;docstring&#x27; and closing tags with &#x27;body&#x27;
        opening_tag = True
        for line_no, line in enumerate(lines):
            if(line.strip() == &#x27;&quot;&quot;&quot;&#x27;):
                lines[line_no] = line.replace(&#x27;&quot;&quot;&quot;&#x27;,&#x27;docstring&#x27; if opening_tag else &#x27;body&#x27;)
                opening_tag = not opening_tag
          
        # find and create document objects and tell them the line numbers
        # that their content starts and ends at
        for line_no, line in enumerate(lines):
            for p in object_signatures:
                if line.strip().startswith(p):
                    obj = docobj(line)
                    obj.content_start = line_no + 1         # start of this object
                    if(len(objects) &gt; 0):           
                        objects[-1].content_end = (line_no) # end of previous object
                    objects.append(obj)
        objects[-1].content_end = len(lines)                # end of last object in document
               
        # tell the object what its indent level is within the document
        indents =[0]
        for obj in objects:
            if(obj.indent_spaces &gt; indents[-1]):
                indents.append(obj.indent_spaces)
            obj.indent_level = indents.index(obj.indent_spaces)

        return objects

</pre>
</details>
</details>
</details>
<details><summary><span class ='def signature'>def object_list_to_HTML(lines, doc_objects):</span></summary>
<details open><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        converts list of doc_objects into HTML
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>    doc_html = &quot;&quot;
    for i,obj in enumerate(doc_objects):
        nextobj = doc_objects[(i+1) % len(doc_objects)]
        details_open = &#x27; open&#x27; if (obj.object_type == &#x27;docstring&#x27;) else &#x27;&#x27;
        doc_html += f&quot;&lt;details{details_open}&gt;&lt;summary&gt;&lt;span class =&#x27;{obj.object_type} {&#x27;signature&#x27;}&#x27;&gt;{obj.signature}&lt;/span&gt;&lt;/summary&gt;\n&quot;
        if(nextobj.indent_level &lt;= obj.indent_level):
            doc_html += f&quot;&lt;pre class =&#x27;{obj.object_type} content&#x27;&gt;&quot;
            for line in lines[obj.content_start:obj.content_end]:
                doc_html += f&quot;{html.escape(line)}&quot;
            doc_html += &quot;&lt;/pre&gt;\n&quot;
            for i in range(obj.indent_level - nextobj.indent_level + 1):
                doc_html += &quot;&lt;/details&gt;\n&quot;
    return doc_html
            
</pre>
</details>
</details>
<details><summary><span class ='def signature'>def main(input_pattern, style_sheet, output_name):</span></summary>
<details open><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        Another docstring for testing
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>    output_html =  f&quot;&lt;!DOCTYPE html&gt;&lt;html lang=&#x27;en&#x27;&gt;\n&lt;head&gt;\n&lt;title&gt;{output_name}&lt;/title&gt;&quot;
    output_html += f&quot;&lt;link rel=&#x27;stylesheet&#x27; href=&#x27;./{style_sheet}&#x27; /&gt;&quot;
    output_html += &quot;&lt;body&gt;\n&quot;

    for filepath in glob.glob(input_pattern):
        filename = os.path.basename(filepath)
        print(f&quot;Found file: {filename}&quot;)
        with open(filepath,&quot;r&quot;) as f:
            lines = f.readlines()
        if(len(lines) ==0):
            print(f&quot;File: {filename} has no content - skipping&quot;)
            continue
        output_html += f&quot;&lt;span class = &#x27;filename&#x27;&gt;{filename}&lt;/span&gt;&lt;br&gt;&quot;
        doc_objects = get_doc_objects(lines)
        output_html += object_list_to_HTML(lines, doc_objects)
        
    output_html += &quot;&lt;/body&gt;\n&quot;
    with open(output_name, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f:
        f.write(output_html)
    print(f&quot;\n\nOutline written to {output_name}.html&quot;)

if __name__ == &quot;__main__&quot;:
    args = parse_args()
    main(args.input, args.style, args.output)

</pre>
</details>
</details>
</body>
