<!DOCTYPE html><html lang='en'>
<head>
<title>docu-lite-necbol-outline-docmode.html</title><link rel='stylesheet' href='./docu-lite-docmode.css' /><body>
<span class = 'filename'>components.py</span><br><hr><div><span class ='class signature'>class components:</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsp__init__(self, starting_tag_nr = 0):</span></div>
<pre class ='docstring content'>        
        Sets object_counter to starting_tag_nr (tags number identifies an object)
        and loads the units module class units()
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspnew_geometry_object(self):</span></div>
<pre class ='docstring content'>        
        increment the object counter and return a GeometryObject with the counter&#x27;s new value
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspcopy_of(self, existing_obj):</span></div>
<pre class ='docstring content'>        
        Returns a clone of existing_obj with a new iTag
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspwire_Z(self, **dimensions):</span></div>
<pre class ='docstring content'>        
        Create a straight wire aligned along the Z-axis, centered at the origin.

        The wire extends from -length/2 to +length/2 on the Z-axis, with the specified diameter.

        dimensions:
            length_{units_string} (float): Length of the wire. 
            wire_diameter_{units_string} (float): Diameter of the wire.
            In each case, the unit suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object with the defined wire.
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprect_loop_XZ(self, **dimensions):</span></div>
<pre class ='docstring content'>        
        Create a rectangular wire loop in the XZ plane, centered at the origin, with the specified wire diameter.
        The &#x27;side&#x27; wires extend from Z=-length/2 to Z=+length/2 at X = +/- width/2.
        The &#x27;top/bottom&#x27; wires extend from X=-width/2 to X=+width/2 at Z = +/- length/2.
        dimensions:
            length_{units_string} (float): &#x27;Length&#x27; (extension along Z) of the rectangle. 
            width_{units_string} (float): &#x27;Width&#x27; (extension along X) of the rectangle. 
            wire_diameter_{units_string} (float): Diameter of the wires.
            In each case, the unit suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object with the defined wires.
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspconnector(self, from_object, from_wire_index, from_alpha_wire, to_object, to_wire_index, to_alpha_wire,  wire_diameter_mm = 1.0):</span></div>
<pre class ='docstring content'>        
        Create a single wire from a specified point on the from_object to a specified point on the to_object.
        The point on an object is specified as {ftom|to}_wire_index AND {ftom|to}_alpha_wire, which specify respectively:
              the i&#x27;th wire in the n wires in the object, and
              the distance along that wire divided by that wire&#x27;s length
        Arguments:
            from_object (GeometryObject), from_wire_index (int, 0 .. n_wires_in_from_object - 1), from_alpha_wire (float, 0 .. 1)
            to_object (GeometryObject), to_wire_index (int, 0 .. n_wires_in_to_object - 1), to_alpha_wire (float, 0 .. 1)
        Returns:
            obj (GeometryObject): The constructed geometry object with the defined wire.
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsphelix(self,  wires_per_turn, sense, **dimensions):</span></div>
<pre class ='docstring content'>        
        Create a single helix with axis = Z axis
        Arguments_
            sense (&quot;LH&quot;|&quot;RH&quot;) - the handedness of the helix          
            wires_per_turn (int) - the number of wires to use to represent the helix, per turn
            dimensions:
                radius_{units} (float) - helix radius 
                length_{units} (float) - helix length along Z 
                pitch_{units} (float)  - helix length along Z per whole turn
                wire_diameter_{units} (float) - diameter of wire making the helix
                In each case above, the units suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object representing the helix.
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspflexi_helix(self, sense, wires_per_turn, n_cos,r_cos_params,p_cos_params, **dimensions):</span></div>
<pre class ='docstring content'>        
        Create a helix along the Z axis where radius and pitch vary as scaled sums of cosines:

            r(Z) = r0 * Î£ [RA_i * cos(i * Ï€ * Z / l + RP_i)] for i=0..n-1
            p(Z) = p0 * Î£ [PA_i * cos(i * Ï€ * Z / l + PP_i)] for i=0..n-1

        The geometry is generated by stepping through helical phase (Ï†), and computing local radius and pitch from cosine series 
        as functions of normalized Ï† (mapped to Z via cumulative pitch integration).

        Parameters:
            sense (str): &quot;RH&quot; or &quot;LH&quot; handedness
            wires_per_turn (int): Resolution (segments per full turn)
            n_cos (int): Number of cosine terms
            r_cos_params (list of tuples): [(RA0, RP0), ...] radius amplitudes and phases
            p_cos_params (list of tuples): [(PA0, PP0), ...] pitch amplitudes and phases
            dimensions:
                l_{units} (float): Approximate helix length along Z
                r0_{units} (float): Base radius scale factor
                p0_{units} (float): Base pitch scale factor (length per full turn)
                wire_diameter_{units} (float): Wire thickness

        Returns:
            GeometryObject: The constructed helix geometry object.
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspcosine_series(s, terms):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspcircular_arc(self, n_wires, arc_phi_deg, **dimensions):</span></div>
<pre class ='docstring content'>        
        Create a single circular arc in the XY plane centred on the origin
        Arguments:
            n_wires (int) - the number of wires to use to represent the arc         
            arc_phi_deg (float) - the angle subtended at the origin by the arc in degrees. Note that a continuous circular loop can be constructed by specifying arc_phi_deg = 360.
            dimensions:
                radius_{units} (float) - helix radius 
                wire_diameter_{units} (float) - diameter of wire making the helix
                In each case above, the units suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object representing the helix.
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspthin_sheet(self, model, sigma, epsillon_r, force_odd = True,</span></div>
<pre class ='docstring content'>        
        Creates a grid of wires interconnected at segment level to economically model a flat sheet
        which is normal to the x axis and extends from z=-height/2 to z= height/2, and y = -length/2 to length/2
        Models *either* conductive or dielectric sheet, not both.
        Set epsillon_r to 1.0 for conductive sheet
        Set epsillon_r &gt; 1.0 for dielectric sheet (conductivity value is then not used)

        Arguments:
            model - the object model being built
            sigma - conductivity in mhos/metre
            epsillon_r - relative dielectric constant
            force_odd = true ensures wires cross at y=z=0
            The four &#x27;close_&#x27; parameters determine whether or not the edges are &#x27;sealed&#x27; with a final wire (if True) or
            not (if False) so that the grid can be joined to other grids without wires overlapping:
                close_end = True completes the grid with a final end z wire at y = length/2 
                close_start = True starts the grid with a z wire at y = -length/2 
                close_top = True completes the grid with a y wire at z = height/2 
                close_bottom = True starts the grid with a y wire at z = -height/2 
            enforce_exact_pitch: if True, length and height are adjusted to fit an integer number
            of grid cells of the specified pitch. If False, length and height remain as specified and
            the grid pitch in Y and Z is adjusted to fit the number of grid cells calculated from the
            grid pitch and force_odd value. Behaviour prior to V2.0.3 was enforce_exact_pitch.

        Dimensions are length_, height_, thickness_, grid_pitch_
</pre>
<span class = 'filename'>gui.py</span><br><hr><div><span class ='def signature'>&nbsp&nbsp&nbspshow_wires(wires, ex_tag, title, color='blue'):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspshow_wires_from_file(file_path, ex_tag, color='blue', title = "3D Viewer"):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspplot_gain(pattern_data, elevation_deg, component, polar=True):</span></div>
<span class = 'filename'>modeller.py</span><br><hr><div><span class ='class signature'>class GeometryObject:</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsp__init__(self, wires):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspadd_wire(self, iTag, nS, x1, y1, z1, x2, y2, z2, wr):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspget_wires(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsptranslate(self, **params):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprotate_ZtoY(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprotate_ZtoX(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprotate_around_Z(self, angle_deg):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprotate_around_X(self, angle_deg):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprotate_around_Y(self, angle_deg):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspcos_sin(self,angle_deg):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprotate(self, R):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspconnect_ends(self, other, tol=1e-3, verbose = False):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsppoint_should_connect_to_wire(self,P, wire, tol=1e-3):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsppoint_on_object(self,geom_object, wire_index, alpha_wire):</span></div>
<hr><div><span class ='class signature'>class units:</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsp__init__(self, default_unit: str = "m"):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspfrom_suffixed_dimensions(self, params: dict, whitelist=[]) -> dict:</span></div>
<pre class ='docstring content'>        
        Converts suffixed values like &#x27;d_mm&#x27; to meters.

        Output keys have &#x27;_m&#x27; suffix unless they already end with &#x27;_m&#x27;,
        in which case they are passed through unchanged (assumed meters).
</pre>
<hr><div><span class ='class signature'>class NECModel:</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsp__init__(self, working_dir, nec_exe_path, model_name = "Unnamed_Antennna", verbose=False):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspset_name(self, name):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspwrite_runner_files(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspset_wire_conductivity(self, sigma):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspset_frequency(self, MHz):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspset_gain_point(self, azimuth, elevation):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspset_gain_az_arc(self, azimuth_start, azimuth_stop, nPoints, elevation):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspset_ground(self, eps_r, sigma, **params):</span></div>
<pre class ='docstring content'>        
            Sets the ground relative permitivity and conductivity. Currently limited to simple choices.
            If eps_r = 1, nec is told to use no ground (free space model), and you may omit the origin height parameter
            If you don&#x27;t call this function, free space will be assumed.
            Othewise you should set the origin height so that the antenna reference point X,Y,Z = (0,0,0) is set to be
            the specified distance above ground.
            Parameters:
                eps_r (float): relative permittivity (relative dielectric constant) of the ground
                sigma (float): conductivity of the ground in mhos/meter
                origin_height_{units_string} (float): Height of antenna reference point X,Y,Z = (0,0,0)
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspstart_geometry(self, comments="No comments specified"):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspplace_series_RLC_load(self, geomObj, R_ohms, L_uH, C_pf, load_alpha_object=-1, load_wire_index=-1, load_alpha_wire=-1):</span></div>
<pre class ='docstring content'>        
            inserts a single segment containing a series RLC load into an existing geometry object
            see _place_feed_or_load for how to specify the position of the segment within the object
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspplace_parallel_RLC_load(self, geomObj, R_ohms, L_uH, C_pf, load_alpha_object=-1, load_wire_index=-1, load_alpha_wire=-1):</span></div>
<pre class ='docstring content'>        
            inserts a single segment containing a parakllel RLC load into an existing geometry object
            see _place_feed_or_load for how to specify the position of the segment within the object
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspplace_feed(self,  geomObj, feed_alpha_object=-1, feed_wire_index=-1, feed_alpha_wire=-1):</span></div>
<pre class ='docstring content'>        
            inserts a single segment containing the excitation point into an existing geometry object
            see _place_feed_or_load for how to specify the position of the segment within the object
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsp_place_feed_or_load(self, geomObj, item_iTag, item_alpha_object, item_wire_index, item_alpha_wire):</span></div>
<pre class ='docstring content'>        
            inserts a single segment with a specified iTag into an existing geometry object
            position within the object is specied as
            EITHER:
              item_alpha_object (range 0 to 1) as a parameter specifying the length of
                                wire traversed to reach the item by following each wire in the object,
                                divided by the length of all wires in the object
            OR:
              item_wire_index AND item_alpha_wire
              which specify the i&#x27;th wire in the n wires in the object, and the distance along that
              wire divided by that wire&#x27;s length
</pre>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspadd(self, geomObj):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspwrite_nec(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprun_nec(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspgains(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsph_gain(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspv_gain(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsptot_gain(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspvswr(self):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspread_radiation_pattern(self):</span></div>
<span class = 'filename'>optimisers.py</span><br><hr><div><span class ='class signature'>class RandomOptimiser:</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsp__init__(self, build_fn, param_init, cost_fn,</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspformat_params(self, params):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspsame_line_print(self,text):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbsprandom_variation(self, x):</span></div>
<hr><div><span class ='def signature'>&nbsp&nbsp&nbspoptimise(self, model,  verbose=False, tty=True):</span></div>

<br><br><span style = 'font-size:0.8em;color:#666;border-top:1px solid #ddd; font-style:italic'>Made with Docu-lite v0.9.0 by Alan Robinson: github.com/G1OJS/docu-lite/</span></body>
