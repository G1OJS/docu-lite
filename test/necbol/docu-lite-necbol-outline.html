<!DOCTYPE html><html lang='en'>
<head>
<title>docu-lite-necbol-outline.html</title><link rel='stylesheet' href='./docu-lite-style.css' /><body>
<span class = 'filename'>components.py</span><br><details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>
This file is part of the &quot;NECBOL Plain Language Python NEC Runner&quot;
Copyright (c) 2025 Alan Robinson G1OJS

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>
import numpy as np
import math
from necbol.modeller import GeometryObject,units

#=================================================================================
# Cannonical components
#=================================================================================

</pre>
</details>
<details><summary><span class ='class signature'>class components:</span></summary>
<pre class ='class content'></pre>
<details><summary><span class ='def signature'>def __init__(self, starting_tag_nr = 0):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
        Sets object_counter to starting_tag_nr (tags number identifies an object)
        and loads the units module class units()
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        self.object_counter = starting_tag_nr
        self.units = units()

</pre>
</details>
</details>
<details><summary><span class ='def signature'>def new_geometry_object(self):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
        increment the object counter and return a GeometryObject with the counter&#x27;s new value
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        self.object_counter += 1
        iTag = self.object_counter
        return iTag, GeometryObject([])

</pre>
</details>
</details>
<details><summary><span class ='def signature'>def copy_of(self, existing_obj):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
        Returns a clone of existing_obj with a new iTag
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        iTag, obj = self.new_geometry_object()
        for w in existing_obj.wires:
            obj.add_wire(iTag, w[&#x27;nS&#x27;], *w[&#x27;a&#x27;], *w[&#x27;b&#x27;], w[&#x27;wr&#x27;])
        return obj
        
</pre>
</details>
</details>
<details><summary><span class ='def signature'>def wire_Z(self, **dimensions):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
        Create a straight wire aligned along the Z-axis, centered at the origin.

        The wire extends from -length/2 to +length/2 on the Z-axis, with the specified diameter.

        dimensions:
            length_{units_string} (float): Length of the wire. 
            wire_diameter_{units_string} (float): Diameter of the wire.
            In each case, the unit suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object with the defined wire.
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        iTag, obj = self.new_geometry_object()
        dimensions_m = self.units.from_suffixed_dimensions(dimensions)
        half_length_m = dimensions_m.get(&#x27;length_m&#x27;)/2
        wire_radius_m = dimensions_m.get(&#x27;wire_diameter_m&#x27;)/2
        obj.add_wire(iTag, 0, 0, 0, -half_length_m, 0, 0, half_length_m, wire_radius_m)
        return obj
    
</pre>
</details>
</details>
<details><summary><span class ='def signature'>def rect_loop_XZ(self, **dimensions):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
        Create a rectangular wire loop in the XZ plane, centered at the origin, with the specified wire diameter.
        The &#x27;side&#x27; wires extend from Z=-length/2 to Z=+length/2 at X = +/- width/2.
        The &#x27;top/bottom&#x27; wires extend from X=-width/2 to X=+width/2 at Z = +/- length/2.
        dimensions:
            length_{units_string} (float): &#x27;Length&#x27; (extension along Z) of the rectangle. 
            width_{units_string} (float): &#x27;Width&#x27; (extension along X) of the rectangle. 
            wire_diameter_{units_string} (float): Diameter of the wires.
            In each case, the unit suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object with the defined wires.
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        iTag, obj = self.new_geometry_object()
        dimensions_m = self.units.from_suffixed_dimensions(dimensions)
        half_length_m = dimensions_m.get(&#x27;length_m&#x27;)/2
        half_width_m = dimensions_m.get(&#x27;width_m&#x27;)/2
        wire_radius_m = dimensions_m.get(&#x27;wire_diameter_m&#x27;)/2        
        obj.add_wire(iTag, 0, -half_width_m , 0, -half_length_m, -half_width_m , 0, half_length_m, wire_radius_m)
        obj.add_wire(iTag, 0,  half_width_m , 0, -half_length_m,  half_width_m , 0, half_length_m, wire_radius_m)
        obj.add_wire(iTag, 0, -half_width_m , 0, -half_length_m,  half_width_m , 0,-half_length_m, wire_radius_m)
        obj.add_wire(iTag, 0, -half_width_m , 0,  half_length_m,  half_width_m , 0, half_length_m, wire_radius_m)
        return obj

</pre>
</details>
</details>
<details><summary><span class ='def signature'>def connector(self, from_object, from_wire_index, from_alpha_wire, to_object, to_wire_index, to_alpha_wire,  wire_diameter_mm = 1.0):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
        Create a single wire from a specified point on the from_object to a specified point on the to_object.
        The point on an object is specified as {ftom|to}_wire_index AND {ftom|to}_alpha_wire, which specify respectively:
              the i&#x27;th wire in the n wires in the object, and
              the distance along that wire divided by that wire&#x27;s length
        Arguments:
            from_object (GeometryObject), from_wire_index (int, 0 .. n_wires_in_from_object - 1), from_alpha_wire (float, 0 .. 1)
            to_object (GeometryObject), to_wire_index (int, 0 .. n_wires_in_to_object - 1), to_alpha_wire (float, 0 .. 1)
        Returns:
            obj (GeometryObject): The constructed geometry object with the defined wire.
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        iTag, obj = self.new_geometry_object()
        from_point = obj.point_on_object(from_object, from_wire_index, from_alpha_wire)
        to_point = obj.point_on_object(to_object, to_wire_index, to_alpha_wire)
        obj.add_wire(iTag, 0, *from_point, *to_point, wire_diameter_mm/2000) 
        return obj

</pre>
</details>
</details>
<details><summary><span class ='def signature'>def helix(self,  wires_per_turn, sense, **dimensions):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
        Create a single helix with axis = Z axis
        Arguments_
            sense (&quot;LH&quot;|&quot;RH&quot;) - the handedness of the helix          
            wires_per_turn (int) - the number of wires to use to represent the helix, per turn
            dimensions:
                radius_{units} (float) - helix radius 
                length_{units} (float) - helix length along Z 
                pitch_{units} (float)  - helix length along Z per whole turn
                wire_diameter_{units} (float) - diameter of wire making the helix
                In each case above, the units suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object representing the helix.
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        iTag, obj = self.new_geometry_object()
        dimensions_m = self.units.from_suffixed_dimensions(dimensions)
        radius_m = dimensions_m.get(&#x27;diameter_m&#x27;)/2
        length_m = dimensions_m.get(&#x27;length_m&#x27;)
        pitch_m = dimensions_m.get(&#x27;pitch_m&#x27;)
        wire_radius_m = dimensions_m.get(&#x27;wire_diameter_m&#x27;)/2

        turns = length_m / pitch_m
        n_wires = int(turns * wires_per_turn)
        delta_phi = (2 * math.pi) / wires_per_turn  # angle per segment
        delta_z_m = pitch_m / wires_per_turn 
        phi_sign = 1 if sense.upper() == &quot;RH&quot; else -1

        for i in range(n_wires):
            phi1 = phi_sign * delta_phi * i
            phi2 = phi_sign * delta_phi * (i + 1)
            x1 = radius_m * math.cos(phi1)
            y1 = radius_m * math.sin(phi1)
            z1 = delta_z_m * i
            x2 = radius_m * math.cos(phi2)
            y2 = radius_m * math.sin(phi2)
            z2 = delta_z_m * (i + 1)
            obj.add_wire(iTag, 0, x1, y1, z1, x2, y2, z2, wire_radius_m)

        return obj

</pre>
</details>
</details>
<details><summary><span class ='def signature'>def flexi_helix(self, sense, wires_per_turn, n_cos,r_cos_params,p_cos_params, **dimensions):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
        Create a helix along the Z axis where radius and pitch vary as scaled sums of cosines:

            r(Z) = r0 * Î£ [RA_i * cos(i * Ï€ * Z / l + RP_i)] for i=0..n-1
            p(Z) = p0 * Î£ [PA_i * cos(i * Ï€ * Z / l + PP_i)] for i=0..n-1

        The geometry is generated by stepping through helical phase (Ï†), and computing local radius and pitch from cosine series 
        as functions of normalized Ï† (mapped to Z via cumulative pitch integration).

        Parameters:
            sense (str): &quot;RH&quot; or &quot;LH&quot; handedness
            wires_per_turn (int): Resolution (segments per full turn)
            n_cos (int): Number of cosine terms
            r_cos_params (list of tuples): [(RA0, RP0), ...] radius amplitudes and phases
            p_cos_params (list of tuples): [(PA0, PP0), ...] pitch amplitudes and phases
            dimensions:
                l_{units} (float): Approximate helix length along Z
                r0_{units} (float): Base radius scale factor
                p0_{units} (float): Base pitch scale factor (length per full turn)
                wire_diameter_{units} (float): Wire thickness

        Returns:
            GeometryObject: The constructed helix geometry object.
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>
</pre>
</details>
<details><summary><span class ='def signature'>def cosine_series(s, terms):</span></summary>
<pre class ='def content'>            return sum(A * math.cos(i * math.pi * s + P) for i, (A, P) in enumerate(terms))

        # === Parameter unpacking and setup ===
        iTag, obj = self.new_geometry_object()
        dimensions_m = self.units.from_suffixed_dimensions(dimensions)

        l_m = dimensions_m.get(&#x27;length_m&#x27;)
        r0_m = dimensions_m.get(&#x27;r0_m&#x27;)
        p0_m = dimensions_m.get(&#x27;p0_m&#x27;)
        wire_radius_m = dimensions_m.get(&#x27;wire_diameter_m&#x27;) / 2

        phi_sign = 1 if sense.upper() == &quot;RH&quot; else -1

        # Estimate number of turns from average pitch and total Z span
        est_turns = l_m / p0_m
        total_phi = est_turns * 2 * math.pi
        n_segments = int(wires_per_turn * est_turns)

        # Precompute all phi values
        phi_list = [i * total_phi / n_segments for i in range(n_segments + 1)]

        # === Generate 3D points ===
        z = -l_m / 2  # center the helix vertically
        points = []

        for i, phi in enumerate(phi_list):
            s = phi / total_phi  # Normalize Ï† to [0, +1]

            radius = r0_m * cosine_series(s, r_cos_params)
            pitch = p0_m * cosine_series(s, p_cos_params)
            delta_phi = total_phi / n_segments

            if i &gt; 0:
                z += pitch * delta_phi / (2 * math.pi)
            x = radius * math.cos(phi_sign * phi)
            y = radius * math.sin(phi_sign * phi)
            points.append((x, y, z))

        # === Create wires ===
        for i in range(n_segments):
            x1, y1, z1 = points[i]
            x2, y2, z2 = points[i + 1]
            obj.add_wire(iTag, 0, x1, y1, z1, x2, y2, z2, wire_radius_m)

        return obj


</pre>
</details>
</details>
<details><summary><span class ='def signature'>def circular_arc(self, n_wires, arc_phi_deg, **dimensions):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
        Create a single circular arc in the XY plane centred on the origin
        Arguments:
            n_wires (int) - the number of wires to use to represent the arc         
            arc_phi_deg (float) - the angle subtended at the origin by the arc in degrees. Note that a continuous circular loop can be constructed by specifying arc_phi_deg = 360.
            dimensions:
                radius_{units} (float) - helix radius 
                wire_diameter_{units} (float) - diameter of wire making the helix
                In each case above, the units suffix (e.g., _mm, _m) must be present in the units class dictionary &#x27;_UNIT_FACTORS&#x27; (see units.py)
        Returns:
            obj (GeometryObject): The constructed geometry object representing the helix.
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        iTag, obj = self.new_geometry_object()
        dimensions_m = self.units.from_suffixed_dimensions(dimensions)
        radius_m = dimensions_m.get(&#x27;diameter_m&#x27;)/2
        wire_radius_m = dimensions_m.get(&#x27;wire_diameter_m&#x27;)/2    

        delta_phi_deg = arc_phi_deg / n_wires        
        for i in range(n_wires):
            ca, sa = obj.cos_sin(delta_phi_deg * i)
            x1 = radius_m * ca
            y1 = radius_m * sa
            ca, sa = obj.cos_sin(delta_phi_deg * (i+1))
            x2 = radius_m * ca
            y2 = radius_m * sa
            obj.add_wire(iTag, 0, x1, y1, 0, x2, y2, 0, wire_radius_m)

        return obj


</pre>
</details>
</details>
<details><summary><span class ='def signature'>def thin_sheet(self, model, sigma, epsillon_r, force_odd = True,</span></summary>
<pre class ='def content'>                   close_start = True, close_end = True,
                   close_bottom = True, close_top = True,
                   enforce_exact_pitch = True,
                   **dimensions):
</pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
        Creates a grid of wires interconnected at segment level to economically model a flat sheet
        which is normal to the x axis and extends from z=-height/2 to z= height/2, and y = -length/2 to length/2
        Models *either* conductive or dielectric sheet, not both.
        Set epsillon_r to 1.0 for conductive sheet
        Set epsillon_r &gt; 1.0 for dielectric sheet (conductivity value is then not used)

        Arguments:
            model - the object model being built
            sigma - conductivity in mhos/metre
            epsillon_r - relative dielectric constant
            force_odd = true ensures wires cross at y=z=0
            The four &#x27;close_&#x27; parameters determine whether or not the edges are &#x27;sealed&#x27; with a final wire (if True) or
            not (if False) so that the grid can be joined to other grids without wires overlapping:
                close_end = True completes the grid with a final end z wire at y = length/2 
                close_start = True starts the grid with a z wire at y = -length/2 
                close_top = True completes the grid with a y wire at z = height/2 
                close_bottom = True starts the grid with a y wire at z = -height/2 
            enforce_exact_pitch: if True, length and height are adjusted to fit an integer number
            of grid cells of the specified pitch. If False, length and height remain as specified and
            the grid pitch in Y and Z is adjusted to fit the number of grid cells calculated from the
            grid pitch and force_odd value. Behaviour prior to V2.0.3 was enforce_exact_pitch.

        Dimensions are length_, height_, thickness_, grid_pitch_
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        
        print(&quot;NOTE: The thin_sheet model has been tested functionally but not validated quantitavely&quot;)
        iTag, obj = self.new_geometry_object()
        dimensions_m = self.units.from_suffixed_dimensions(dimensions)
        length_m = dimensions_m.get(&#x27;length_m&#x27;)
        height_m = dimensions_m.get(&#x27;height_m&#x27;)
        grid_pitch_m = dimensions_m.get(&#x27;grid_pitch_m&#x27;)
        thickness_m = dimensions_m.get(&#x27;thickness_m&#x27;)
        E = epsillon_r     
        dG = grid_pitch_m

        nY = int(length_m / dG) + 1
        nZ = int(height_m / dG) + 1
        if (force_odd):
            nY += (nY+1) % 2
            nZ += (nZ+1) % 2
        if (enforce_exact_pitch):
            L = (nY-1)*dG
            H = (nZ-1)*dG
            dY = dG
            dZ = dG
        else:
            dY = L/(nY-1)
            dZ = H/(nz-1)
        E0 = 8.854188 * 1e-12
        CD = E0*(E-1) * thickness_m
        wire_radius_m = thickness_m/2

        # Create sheet
        i0 = 0 if close_start else 1
        i1 = nY if close_end else nY-1
        j0 = 0 if close_bottom else 1
        j1 = nZ if close_top else nZ-1
        for i in range(i0, i1):     # make z wires
            x1, y1, z1, x2, y2, z2 = [0, -L/2+i*dY, -H/2, 0, -L/2+i*dY, H/2]
            nSegs = nZ-1
            obj.add_wire(iTag, nSegs, x1, y1, z1, x2, y2, z2, wire_radius_m)

        for j in range(j0, j1):     # make y wires
            x1, y1, z1, x2, y2, z2 = [0, -L/2, -H/2+j*dZ, 0, L/2, -H/2+j*dZ]
            nSegs = nY-1
            obj.add_wire(iTag, nSegs, x1, y1, z1, x2, y2, z2, wire_radius_m)

        # add conductive / capacitive load to the iTag of this object
        # note we aren&#x27;t ineserting a new segment specifically for the load, so there&#x27;s no need to
        # increment model.LOAD_iTag
        if(epsillon_r &gt; 1.0):
            R_Ohms = 1e12
            C_F = CD
        else:
            R_Ohms = dG / sigma
            C_F = 0.0
        model.LOADS.append(f&quot;LD 1 {iTag} 0 0 {R_Ohms:.6e} {1e-12:.6e} {CD:.6e}\n&quot;)
                    
        return obj


</pre>
</details>
</details>
</details>
<span class = 'filename'>gui.py</span><br><details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>
This file is part of the &quot;NECBOL Plain Language Python NEC Runner&quot;
Copyright (c) 2025 Alan Robinson G1OJS

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>
</pre>
</details>
<details><summary><span class ='def signature'>def show_wires(wires, ex_tag, title, color='blue'):</span></summary>
<pre class ='def content'>    import matplotlib.pyplot as plt
    from mpl_toolkits.mplot3d import Axes3D

    print(&quot;Drawing geometry. Please close the geometry window to continue.&quot;)
    fig = plt.figure()
 #   fig.canvas.manager.set_window_title(&#x27;Please close this window to continue&#x27;)
    ax = fig.add_subplot(111, projection=&#x27;3d&#x27;)

    for start, end, tag in wires:
        ax.plot(*zip(start, end), color=color if (tag!=ex_tag) else &#x27;red&#x27;)

    plt.draw()  # ensure autoscale limits are calculated

    # Get axis limits
    xlim, ylim, zlim = ax.get_xlim(), ax.get_ylim(), ax.get_zlim()
    mids = [(lim[0] + lim[1]) / 2 for lim in (xlim, ylim, zlim)]
    spans = [lim[1] - lim[0] for lim in (xlim, ylim, zlim)]
    max_range = max(spans)

    # Set equal range around each midpoint
    ax.set_xlim(mids[0] - max_range/2, mids[0] + max_range/2)
    ax.set_ylim(mids[1] - max_range/2, mids[1] + max_range/2)
    ax.set_zlim(mids[2] - max_range/2, mids[2] + max_range/2)

    ax.set_xlabel(&#x27;X&#x27;)
    ax.set_ylabel(&#x27;Y&#x27;)
    ax.set_zlabel(&#x27;Z&#x27;)
    ax.set_title(title)
    
    plt.tight_layout()
    plt.show()
    

</pre>
</details>
<details><summary><span class ='def signature'>def show_wires_from_file(file_path, ex_tag, color='blue', title = "3D Viewer"):</span></summary>
<pre class ='def content'>    wires = []
    with open(file_path, &#x27;r&#x27;) as f:
        for line in f:
            if line.startswith(&quot;GW&quot;):
                parts = line.strip().split()
                if len(parts) &gt;= 9:
                    # NEC input is: GW tag seg x1 y1 z1 x2 y2 z2 radius
                    x1, y1, z1 = map(float, parts[3:6])
                    x2, y2, z2 = map(float, parts[6:9])
                    tag = int(parts[1])
                    wires.append(((x1, y1, z1), (x2, y2, z2), tag))
    show_wires(wires, ex_tag, title, color=color)


</pre>
</details>
<details><summary><span class ='def signature'>def plot_gain(pattern_data, elevation_deg, component, polar=True):</span></summary>
<pre class ='def content'>    import matplotlib.pyplot as plt
    import numpy as np
        
    # Filter data for fixed elevation (theta)
    theta_cut = 90 - elevation_deg
    print(f&quot;Plotting gain for elevation = {elevation_deg} i.e. theta = {theta_cut}&quot;)
    az_cut = [d for d in pattern_data if abs(d[&#x27;theta&#x27;] - theta_cut) &lt; 0.1]

    # Sort by phi (just in case)
    az_cut.sort(key=lambda d: d[&#x27;phi&#x27;])

    # Extract azimuth (phi) and gain
    phi_deg = [d[&#x27;phi&#x27;] for d in az_cut]
    gain_db = [d[component] for d in az_cut]
    max_gain = np.max(gain_db)

    title = f&#x27;{component} at elevation = {elevation_deg}Â°&#x27;

    if polar:
        phi_rad = np.radians(phi_deg)
        fig, ax = plt.subplots(subplot_kw={&#x27;projection&#x27;: &#x27;polar&#x27;})
        ax.plot(phi_rad, gain_db, label=title)
        ax.set_title(title)
        ax.grid(True)
        ax.set_rmax(max_gain)
        ax.set_rmin(max_gain-40)
        ax.set_rlabel_position(90)
    else:
        fig, ax = plt.subplots()
        ax.plot(phi_deg, gain_db, label=title)
        ax.set_xlabel(&#x27;Azimuth Ï† (degrees)&#x27;)
        ax.set_ylabel(&#x27;Gain (dB)&#x27;)
        ax.set_ylim([max_gain-40,max_gain])
        ax.grid(True)
  
    plt.show()




</pre>
</details>
<span class = 'filename'>modeller.py</span><br><details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>
This file is part of the &quot;NECBOL Plain Language Python NEC Runner&quot;
Copyright (c) 2025 Alan Robinson G1OJS

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>
import numpy as np
import math
import warnings
import subprocess
import os

#=================================================================================
# The geometry object that holds a single component plus its methods
#=================================================================================

</pre>
</details>
<details><summary><span class ='class signature'>class GeometryObject:</span></summary>
<pre class ='class content'></pre>
<details><summary><span class ='def signature'>def __init__(self, wires):</span></summary>
<pre class ='def content'>        self.wires = wires  # list of wire dicts with iTag, nS, x1, y1, ...
        self.units = units()

</pre>
</details>
<details><summary><span class ='def signature'>def add_wire(self, iTag, nS, x1, y1, z1, x2, y2, z2, wr):</span></summary>
<pre class ='def content'>        self.wires.append({&quot;iTag&quot;:iTag, &quot;nS&quot;:nS, &quot;a&quot;:(x1, y1, z1), &quot;b&quot;:(x2, y2, z2), &quot;wr&quot;:wr})

</pre>
</details>
<details><summary><span class ='def signature'>def get_wires(self):</span></summary>
<pre class ='def content'>        return self.wires

</pre>
</details>
<details><summary><span class ='def signature'>def translate(self, **params):</span></summary>
<pre class ='def content'>        params_m = self.units.from_suffixed_dimensions(params)
        for w in self.wires:
            w[&#x27;a&#x27;] = tuple(map(float,np.array(w[&#x27;a&#x27;]) + np.array([params_m.get(&#x27;dx_m&#x27;), params_m.get(&#x27;dy_m&#x27;), params_m.get(&#x27;dz_m&#x27;)])))
            w[&#x27;b&#x27;] = tuple(map(float,np.array(w[&#x27;b&#x27;]) + np.array([params_m.get(&#x27;dx_m&#x27;), params_m.get(&#x27;dy_m&#x27;), params_m.get(&#x27;dz_m&#x27;)])))

</pre>
</details>
<details><summary><span class ='def signature'>def rotate_ZtoY(self):</span></summary>
<pre class ='def content'>        R = np.array([[1, 0, 0],[0,  0, 1],[0,  -1, 0]])
        return self.rotate(R)
    
</pre>
</details>
<details><summary><span class ='def signature'>def rotate_ZtoX(self):</span></summary>
<pre class ='def content'>        R = np.array([[0, 0, 1],[0,  1, 0],[-1,  0, 0]])
        return self.rotate(R)

</pre>
</details>
<details><summary><span class ='def signature'>def rotate_around_Z(self, angle_deg):</span></summary>
<pre class ='def content'>        ca, sa = self.cos_sin(angle_deg)
        R = np.array([[ca, -sa, 0],
                      [sa, ca, 0],
                      [0, 0, 1]])
        return self.rotate(R)

</pre>
</details>
<details><summary><span class ='def signature'>def rotate_around_X(self, angle_deg):</span></summary>
<pre class ='def content'>        ca, sa = self.cos_sin(angle_deg)
        R = np.array([[1, 0, 0],
                      [0, ca, -sa],
                      [0, sa, ca]])
        return self.rotate(R)

</pre>
</details>
<details><summary><span class ='def signature'>def rotate_around_Y(self, angle_deg):</span></summary>
<pre class ='def content'>        ca, sa = self.cos_sin(angle_deg)
        R = np.array([[ca, 0, sa],
                      [0, 1, 0],
                      [-sa, 0, ca]])
        return self.rotate(R)

</pre>
</details>
<details><summary><span class ='def signature'>def cos_sin(self,angle_deg):</span></summary>
<pre class ='def content'>        angle_rad = math.pi*angle_deg/180
        ca = math.cos(angle_rad)
        sa = math.sin(angle_rad)
        return ca, sa
    
</pre>
</details>
<details><summary><span class ='def signature'>def rotate(self, R):</span></summary>
<pre class ='def content'>        for w in self.wires:
            a = np.array(w[&#x27;a&#x27;])
            b = np.array(w[&#x27;b&#x27;])
            w[&#x27;a&#x27;] = tuple(map(float, R @ a))
            w[&#x27;b&#x27;] = tuple(map(float, R @ b))

</pre>
</details>
<details><summary><span class ='def signature'>def connect_ends(self, other, tol=1e-3, verbose = False):</span></summary>
<pre class ='def content'>        wires_to_add=[]
        for ws in self.wires:
            if(verbose):
                print(f&quot;\nChecking if ends of wire from {ws[&#x27;a&#x27;]} to {ws[&#x27;b&#x27;]} should connect to any of {len(other.wires)} other wires:&quot;)
            for es in [ws[&quot;a&quot;], ws[&quot;b&quot;]]:
                for wo in other.wires:
                    if (self.point_should_connect_to_wire(es,wo,tol)):
                        wire_seg_status = f&quot;{wo[&#x27;nS&#x27;]} segment&quot; if wo[&#x27;nS&#x27;] &gt; 0 else &#x27;unsegmented&#x27;
                        length_orig = np.linalg.norm(np.array(wo[&quot;a&quot;]) - np.array(wo[&quot;b&quot;]))
                        b_orig = wo[&quot;b&quot;]
                        wo[&#x27;b&#x27;]=tuple(es)
                        length_shortened = np.linalg.norm(np.array(wo[&quot;a&quot;]) - np.array(wo[&quot;b&quot;]))
                        nS_shortened = max(1, int(wo[&#x27;nS&#x27;]*length_shortened/length_orig))
                        nS_orig = wo[&#x27;nS&#x27;]
                        wo[&#x27;nS&#x27;] = nS_shortened
                        nS_remainder = max(1,nS_orig - nS_shortened)
                        wires_to_add.append( (wo[&#x27;iTag&#x27;], nS_remainder, *wo[&#x27;b&#x27;], *b_orig, wo[&#x27;wr&#x27;]) )
                        length_remainder = np.linalg.norm(np.array(wo[&quot;b&quot;]) - np.array(b_orig))
                        if(verbose):
                            print(f&quot;Inserting end of wire at {wo[&#x27;b&#x27;]} into {wire_seg_status} wire {length_orig}m wire from {wo[&#x27;a&#x27;]} to {b_orig}:&quot;)
                            print(f&quot;    by shortening wire to end at {wo[&#x27;b&#x27;]}: {length_shortened}m, using {nS_shortened} segments&quot;)
                            print(f&quot;    and adding wire from {wo[&quot;b&quot;]} to {b_orig}:  {length_remainder}m using {nS_remainder} segments&quot;)
                        break #(for efficiency only)
        for params in wires_to_add:
            other.add_wire(*params)

</pre>
</details>
<details><summary><span class ='def signature'>def point_should_connect_to_wire(self,P, wire, tol=1e-3):</span></summary>
<pre class ='def content'>        P = np.array(P, dtype=float)
        A = np.array(wire[&#x27;a&#x27;], dtype=float)
        B = np.array(wire[&#x27;b&#x27;], dtype=float)
        AB = B - A
        AP = P - A
        AB_len = np.linalg.norm(AB)
        # can&#x27;t connect to a zero length wire using the splitting method
        if AB_len == 0:
            return False
        
        # Check perpendicular distance from wire axis
        # if we aren&#x27;t close enough to the wire axis to need to connect, return false
        # NOTE: need to align tol with nec&#x27;s check of volumes intersecting
        perp_dist = np.linalg.norm(np.cross(AP, AB)) / AB_len
        if perp_dist &gt; tol: 
            return False    

        # Project point onto the wire to get fractional position
        alpha = np.dot(AP, AB) / (AB_len**2)
        if not (0 &lt;= alpha &lt;= 1):
            return False  # point is on the wire axis but not between the wire ends

        # If we are within allowable tolerance of the wire ends, don&#x27;t split the wire
        dist_from_end = min(alpha*AB_len, (1-alpha)*AB_len)
        if (dist_from_end &lt; tol):
            return False

        # IF the wire is already segmented (e.g. in a grid), check how far from the
        # *nearest* segment boundary this projected alpha is
        if(wire[&#x27;nS&#x27;]&gt;0):
            segment_pitch = 1 / wire[&#x27;nS&#x27;]
            nearest_alpha = round(alpha / segment_pitch) * segment_pitch
            alpha_dist = abs(alpha - nearest_alpha)
            alpha_tol = tol / AB_len  # convert spatial tol to alpha-space
            if alpha_dist &lt; alpha_tol:
                return False  # near a segment end â€” NEC will handle this as a normal junction

        return True  # wire needs to be split to allow the connection

</pre>
</details>
<details><summary><span class ='def signature'>def point_on_object(self,geom_object, wire_index, alpha_wire):</span></summary>
<pre class ='def content'>        if(wire_index&gt; len(geom_object.wires)):
            wire_index = len(geom_object.wires)
            alpha_wire = 1.0
        w = geom_object.wires[wire_index]
        A = np.array(w[&quot;a&quot;], dtype=float)
        B = np.array(w[&quot;b&quot;], dtype=float)
        P = A + alpha_wire * (B-A)
        return P
         
#=================================================================================
# Units processor
#=================================================================================

</pre>
</details>
</details>
<details><summary><span class ='class signature'>class units:</span></summary>
<pre class ='class content'>    
    _UNIT_FACTORS = {
        &quot;m&quot;: 1.0,
        &quot;mm&quot;: 1000.0,
        &quot;cm&quot;: 100.0,
        &quot;in&quot;: 39.3701,
        &quot;ft&quot;: 3.28084,
    }

</pre>
<details><summary><span class ='def signature'>def __init__(self, default_unit: str = "m"):</span></summary>
<pre class ='def content'>        if default_unit not in self._UNIT_FACTORS:
            raise ValueError(f&quot;Unsupported unit: {default_unit}&quot;)
        self.default_unit = default_unit

</pre>
</details>
<details><summary><span class ='def signature'>def from_suffixed_dimensions(self, params: dict, whitelist=[]) -> dict:</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
        Converts suffixed values like &#x27;d_mm&#x27; to meters.

        Output keys have &#x27;_m&#x27; suffix unless they already end with &#x27;_m&#x27;,
        in which case they are passed through unchanged (assumed meters).
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        
        out = {}
        names_seen = []
        for key, value in params.items():
    
            if not isinstance(value, (int, float)):
                continue  # skip nested dicts or other structures

            name = key
            suffix = &quot;&quot;
            if &quot;_&quot; in name:
                name, suffix = name.rsplit(&quot;_&quot;, 1)
                
            if(name in names_seen):
                warnstr = f&quot;Duplicate value of &#x27;{name}&#x27; seen: ignoring latest ({key} = {value})&quot;
                warnings.warn(warnstr)
                continue

            names_seen.append(name)

            if suffix in self._UNIT_FACTORS:
                # Convert value, output key with &#x27;_m&#x27; suffix
                out[name + &quot;_m&quot;] = value / self._UNIT_FACTORS[suffix]
                continue

            if key in whitelist:
                continue
            
            # fallback: no recognised suffix, assume metres
            warnings.warn(f&quot;No recognised units specified for {name}: &#x27;{suffix}&#x27; specified, metres assumed&quot;)
            # output key gets &#x27;_m&#x27; suffix added
            out[name + &quot;_m&quot;] = value

        return out


#=================================================================================
# NEC Wrapper functions for writing .nec file and reading output
#=================================================================================

</pre>
</details>
</details>
</details>
<details><summary><span class ='class signature'>class NECModel:</span></summary>
<pre class ='class content'></pre>
<details><summary><span class ='def signature'>def __init__(self, working_dir, nec_exe_path, model_name = "Unnamed_Antennna", verbose=False):</span></summary>
<pre class ='def content'>        self.verbose = verbose
        self.working_dir = working_dir
        self.nec_exe = nec_exe_path
        self.nec_bat = working_dir + &quot;\\nec.bat&quot;
        self.nec_in = working_dir + &quot;\\&quot; + model_name +  &quot;.nec&quot;
        self.nec_out = working_dir + &quot;\\&quot; + model_name +  &quot;.out&quot;
        self.files_txt = working_dir + &quot;\\files.txt&quot;
        self.model_name = model_name
        self.model_text = &quot;&quot;
        self.LD_WIRECOND = &quot;&quot;
        self.FR_CARD = &quot;&quot;
        self.RP_CARD = &quot;&quot;
        self.GE_CARD = &quot;GE 0\n&quot;
        self.GN_CARD = &quot;&quot;
        self.GM_CARD = &quot;&quot;
        self.comments = &quot;&quot;
        self.EX_TAG = 999
        self.nSegs_per_wavelength = 40
        self.segLength_m = 0
        self.units = units()
        self.write_runner_files()

</pre>
</details>
<details><summary><span class ='def signature'>def set_name(self, name):</span></summary>
<pre class ='def content'>        self.model_name = name
        self.nec_in = self.working_dir + &quot;\\&quot; + self.model_name +  &quot;.nec&quot;
        self.nec_out = self.working_dir + &quot;\\&quot; + self.model_name +  &quot;.out&quot;
        self.write_runner_files()

</pre>
</details>
<details><summary><span class ='def signature'>def write_runner_files(self):</span></summary>
<pre class ='def content'>        for filepath, content in [
            (self.nec_bat, f&quot;{self.nec_exe} &lt; {self.files_txt} \n&quot;),
            (self.files_txt, f&quot;{self.nec_in}\n{self.nec_out}\n&quot;)
        ]:
            directory = os.path.dirname(filepath)
            if directory and not os.path.exists(directory):
                os.makedirs(directory)  # create directory if it doesn&#x27;t exist
            try:
                with open(filepath, &quot;w&quot;) as f:
                    f.write(content)
            except Exception as e:
                print(f&quot;Error writing file {filepath}: {e}&quot;)


</pre>
</details>
<details><summary><span class ='def signature'>def set_wire_conductivity(self, sigma):</span></summary>
<pre class ='def content'>        self.LD_WIRECOND = f&quot;LD 5 0 0 0 {sigma:.6f} \n&quot;

</pre>
</details>
<details><summary><span class ='def signature'>def set_frequency(self, MHz):</span></summary>
<pre class ='def content'>        self.FR_CARD = f&quot;FR 0 1 0 0 {MHz:.3f} 0\n&quot;
        lambda_m = 300/MHz
        self.segLength_m = lambda_m / self.nSegs_per_wavelength
        
</pre>
</details>
<details><summary><span class ='def signature'>def set_gain_point(self, azimuth, elevation):</span></summary>
<pre class ='def content'>        self.RP_CARD = f&quot;RP 0 1 1 1000 {90-elevation:.2f} {azimuth:.2f} 0 0\n&quot;

</pre>
</details>
<details><summary><span class ='def signature'>def set_gain_az_arc(self, azimuth_start, azimuth_stop, nPoints, elevation):</span></summary>
<pre class ='def content'>        if(nPoints&lt;2):
            nPoints=2
        dAz = (azimuth_stop - azimuth_start) / (nPoints-1)
        self.RP_CARD = f&quot;RP 0 1 {nPoints} 1000 {90-elevation:.2f} {azimuth_start:.2f} 0 {dAz:.2f}\n&quot;

</pre>
</details>
<details><summary><span class ='def signature'>def set_ground(self, eps_r, sigma, **params):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
            Sets the ground relative permitivity and conductivity. Currently limited to simple choices.
            If eps_r = 1, nec is told to use no ground (free space model), and you may omit the origin height parameter
            If you don&#x27;t call this function, free space will be assumed.
            Othewise you should set the origin height so that the antenna reference point X,Y,Z = (0,0,0) is set to be
            the specified distance above ground.
            Parameters:
                eps_r (float): relative permittivity (relative dielectric constant) of the ground
                sigma (float): conductivity of the ground in mhos/meter
                origin_height_{units_string} (float): Height of antenna reference point X,Y,Z = (0,0,0)
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        if eps_r == 1.0:
            self.GE_CARD = &quot;GE 0\n&quot;
            self.GN_CARD = &quot;&quot;
            self.GM_CARD = &quot;GM 0 0 0 0 0 0 0 0.000\n&quot;
        else:
            origin_height_m = self.units.from_suffixed_dimensions(params)[&#x27;origin_height_m&#x27;]
            self.GE_CARD = &quot;GE -1\n&quot;
            self.GN_CARD = f&quot;GN 2 0 0 0 {eps_r:.3f} {sigma:.3f} \n&quot;
            self.GM_CARD = f&quot;GM 0 0 0 0 0 0 0 {origin_height_m:.3f}\n&quot;

</pre>
</details>
</details>
<details><summary><span class ='def signature'>def start_geometry(self, comments="No comments specified"):</span></summary>
<pre class ='def content'>        # effectively *resets* the model, except that all of the parameters
        # set by set_ functions are still incorporated when the file is written
        self.comments = comments
        self.model_text = &quot;CM &quot; + comments + &quot;\nCE\n&quot;
        # TO DO: decide if 500 is the right tag to start at, and whether to limit # of loads
        self.LOAD_iTag = 500
        self.LOADS = []

</pre>
</details>
<details><summary><span class ='def signature'>def place_series_RLC_load(self, geomObj, R_ohms, L_uH, C_pf, load_alpha_object=-1, load_wire_index=-1, load_alpha_wire=-1):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
            inserts a single segment containing a series RLC load into an existing geometry object
            see _place_feed_or_load for how to specify the position of the segment within the object
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        self.LOADS.append(f&quot;LD 0 {self.LOAD_iTag} 0 0 {R_ohms} {L_uH * 1e-6} {C_pf * 1e-12}\n&quot;)
        self._place_feed_or_load(geomObj, self.LOAD_iTag, load_alpha_object, load_wire_index, load_alpha_wire)
        self.LOAD_iTag +=1
        
</pre>
</details>
</details>
<details><summary><span class ='def signature'>def place_parallel_RLC_load(self, geomObj, R_ohms, L_uH, C_pf, load_alpha_object=-1, load_wire_index=-1, load_alpha_wire=-1):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
            inserts a single segment containing a parakllel RLC load into an existing geometry object
            see _place_feed_or_load for how to specify the position of the segment within the object
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        self.LOADS.append(f&quot;LD 1 {self.LOAD_iTag} 0 0 {R_ohms} {L_uH * 1e-6} {C_pf * 1e-12}\n&quot;)
        self._place_feed_or_load(geomObj, self.LOAD_iTag, load_alpha_object, load_wire_index, load_alpha_wire)
        self.LOAD_iTag +=1

</pre>
</details>
</details>
<details><summary><span class ='def signature'>def place_feed(self,  geomObj, feed_alpha_object=-1, feed_wire_index=-1, feed_alpha_wire=-1):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
            inserts a single segment containing the excitation point into an existing geometry object
            see _place_feed_or_load for how to specify the position of the segment within the object
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        self._place_feed_or_load(geomObj, self.EX_TAG, feed_alpha_object, feed_wire_index, feed_alpha_wire)

</pre>
</details>
</details>
<details><summary><span class ='def signature'>def _place_feed_or_load(self, geomObj, item_iTag, item_alpha_object, item_wire_index, item_alpha_wire):</span></summary>
<pre class ='def content'></pre>
<details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>        
            inserts a single segment with a specified iTag into an existing geometry object
            position within the object is specied as
            EITHER:
              item_alpha_object (range 0 to 1) as a parameter specifying the length of
                                wire traversed to reach the item by following each wire in the object,
                                divided by the length of all wires in the object
            OR:
              item_wire_index AND item_alpha_wire
              which specify the i&#x27;th wire in the n wires in the object, and the distance along that
              wire divided by that wire&#x27;s length
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>        wires = geomObj.get_wires()
        if(item_alpha_object &gt;=0):
            item_wire_index = min(len(wires)-1,int(item_alpha_object*len(wires))) # 0 to nWires -1
            item_alpha_wire = item_alpha_object - item_wire_index
        w = wires[item_wire_index]       

        # calculate wire length vector AB, length a to b and distance from a to feed point
        A = np.array(w[&quot;a&quot;], dtype=float)
        B = np.array(w[&quot;b&quot;], dtype=float)
        AB = B-A
        wLen = np.linalg.norm(AB)
        feedDist = wLen * item_alpha_wire

        if (wLen &lt;= self.segLength_m):
            # feed segment is all of this wire, so no need to split
            w[&#x27;nS&#x27;] = 1
            w[&#x27;iTag&#x27;] = item_iTag
        else:
            # split the wire AB into three wires: A to C, CD (feed segment), D to B
            nS1 = int(feedDist / self.segLength_m)              # no need for min of 1 as we always have the feed segment
            C = A + AB * (nS1 * self.segLength_m) / wLen        # feed segment end a
            D = A + AB * ((nS1+1) * self.segLength_m) / wLen    # feed segment end b
            nS2 = int((wLen-feedDist) / self.segLength_m)       # no need for min of 1 as we always have the feed segment
            # write results back to geomObj: modify existing wire to end at C, add feed segment CD and final wire DB
            # (nonzero nS field is preserved during segmentation in &#x27;add&#x27;)
            w[&#x27;b&#x27;] = tuple(C)
            w[&#x27;nS&#x27;] = nS1
            geomObj.add_wire(item_iTag , 1, *C, *D, w[&quot;wr&quot;])
            geomObj.add_wire(w[&quot;iTag&quot;] , nS2, *D, *B, w[&quot;wr&quot;])
            
                
</pre>
</details>
</details>
<details><summary><span class ='def signature'>def add(self, geomObj):</span></summary>
<pre class ='def content'>        for w in geomObj.get_wires():
            A = np.array(w[&quot;a&quot;], dtype=float)
            B = np.array(w[&quot;b&quot;], dtype=float)
            if(w[&#x27;nS&#x27;] == 0): # calculate and update number of segments only if not already present
                w[&#x27;nS&#x27;] = 1+int(np.linalg.norm(B-A) / self.segLength_m)
            self.model_text += f&quot;GW {w[&#x27;iTag&#x27;]} {w[&#x27;nS&#x27;]} &quot;
            for v in A:
                self.model_text += f&quot;{v:.3f} &quot;
            for v in B:
                self.model_text += f&quot;{v:.3f} &quot;
            self.model_text += f&quot;{w[&#x27;wr&#x27;]}\n&quot;

</pre>
</details>
<details><summary><span class ='def signature'>def write_nec(self):</span></summary>
<pre class ='def content'>        tail_text = self.GM_CARD
        tail_text += self.GE_CARD
        tail_text += self.GN_CARD
        tail_text += &quot;EK\n&quot;
        tail_text += self.LD_WIRECOND
        for LD in self.LOADS:
            tail_text += LD
        tail_text += f&quot;EX 0 {self.EX_TAG} 1 0 1 0\n&quot;
        tail_text += self.FR_CARD
        tail_text += self.RP_CARD
        tail_text += &quot;EN&quot;
        with open(self.nec_in, &quot;w&quot;) as f:
            f.write(self.model_text + tail_text)

</pre>
</details>
<details><summary><span class ='def signature'>def run_nec(self):</span></summary>
<pre class ='def content'>        subprocess.run([self.nec_bat], creationflags=subprocess.CREATE_NO_WINDOW)

</pre>
</details>
<details><summary><span class ='def signature'>def gains(self):</span></summary>
<pre class ='def content'>        try:
            with open(self.nec_out) as f:
                while &quot;RADIATION PATTERNS&quot; not in f.readline():
                    pass
                for _ in range(5):
                    l = f.readline()
                if self.verbose:
                    print(&quot;Gains line:&quot;, l.strip())
        except (RuntimeError, ValueError):
            raise ValueError(f&quot;Something went wrong reading gains from {nec_out}&quot;)

        return {
            &quot;v_gain&quot;: float(l[21:29]),
            &quot;h_gain&quot;: float(l[29:37]),
            &quot;total&quot;: float(l[37:45]),
        }

</pre>
</details>
<details><summary><span class ='def signature'>def h_gain(self):</span></summary>
<pre class ='def content'>        return self.gains()[&#x27;h_gain&#x27;]

</pre>
</details>
<details><summary><span class ='def signature'>def v_gain(self):</span></summary>
<pre class ='def content'>        return self.gains()[&#x27;v_gain&#x27;]

</pre>
</details>
<details><summary><span class ='def signature'>def tot_gain(self):</span></summary>
<pre class ='def content'>        return self.gains()[&#x27;total&#x27;]

</pre>
</details>
<details><summary><span class ='def signature'>def vswr(self):</span></summary>
<pre class ='def content'>        try:
            with open(self.nec_out) as f:
                while &quot;ANTENNA INPUT PARAMETERS&quot; not in f.readline():
                    pass
                for _ in range(4):
                    l = f.readline()
                if self.verbose:
                    print(&quot;Z line:&quot;, l.strip())
                r = float(l[60:72])
                x = float(l[72:84])
        except (RuntimeError, ValueError):
            raise ValueError(f&quot;Something went wrong reading input impedance from {nec_out}&quot;)

        z_in = r + x * 1j
        z0 = 50
        gamma = (z_in - z0) / (z_in + z0)
        return (1 + abs(gamma)) / (1 - abs(gamma))

</pre>
</details>
<details><summary><span class ='def signature'>def read_radiation_pattern(self):</span></summary>
<pre class ='def content'>        data = []
        in_data = False
        start_lineNo = 1e9
        with open(self.nec_out) as f:
            lines = f.readlines()
        for lineNo, line in enumerate(lines):
            if (&#x27;RADIATION PATTERNS&#x27; in line):
                in_data = True
                start_lineNo = lineNo + 5

            if (lineNo &gt; start_lineNo and line==&quot;\n&quot;):
                in_data = False
                
            if (in_data and lineNo &gt;= start_lineNo):
                theta = float(line[0:9])
                phi = float(line[9:18])
                gain_vert = float(line[18:28])
                gain_horz = float(line[28:36])
                gain_total = float(line[36:45])
                axial_ratio = float(line[45:55])
                tilt_deg = float(line[55:63])
                # SENSE is a string (LINEAR, LHCP, RHCP, etc.)
                sense = line[63:72].strip()
                e_theta_mag = float(line[72:87])
                e_theta_phase = float(line[87:96])
                e_phi_mag = float(line[96:111])
                e_phi_phase = float(line[111:119])

                data.append({
                    &#x27;theta&#x27;: theta,
                    &#x27;phi&#x27;: phi,
                    &#x27;gain_vert_db&#x27;: gain_vert,
                    &#x27;gain_horz_db&#x27;: gain_horz,
                    &#x27;gain_total_db&#x27;: gain_total,
                    &#x27;axial_ratio&#x27;: axial_ratio,
                    &#x27;tilt_deg&#x27;: tilt_deg,
                    &#x27;sense&#x27;: sense,
                    &#x27;E_theta_mag&#x27;: e_theta_mag,
                    &#x27;E_theta_phase_deg&#x27;: e_theta_phase,
                    &#x27;E_phi_mag&#x27;: e_phi_mag,
                    &#x27;E_phi_phase_deg&#x27;: e_phi_phase
                })


        return data

</pre>
</details>
</details>
<span class = 'filename'>optimisers.py</span><br><details><summary><span class ='docstring signature'>docstring</span></summary>
<pre class ='docstring content'>
This file is part of the &quot;NECBOL Plain Language Python NEC Runner&quot;
Copyright (c) 2025 Alan Robinson G1OJS

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</pre>
</details>
<details><summary><span class ='body signature'>body</span></summary>
<pre class ='body content'>

import random, sys

</pre>
</details>
<details><summary><span class ='class signature'>class RandomOptimiser:</span></summary>
<pre class ='class content'></pre>
<details><summary><span class ='def signature'>def __init__(self, build_fn, param_init, cost_fn,</span></summary>
<pre class ='def content'>                 bounds={}, delta_init=0.2, stall_limit=50, max_iter=250, min_delta=0.001):
        self.build_fn = build_fn
        self.param_names = list(param_init.keys())
        self.x_baseline = param_init.copy()
        self.bounds = bounds
        self.cost_fn = cost_fn
        self.delta_x = delta_init
        self.min_delta = min_delta
        self.stall_limit = stall_limit
        self.max_iter = max_iter

</pre>
</details>
<details><summary><span class ='def signature'>def format_params(self, params):</span></summary>
<pre class ='def content'>        s=&quot;{&quot;
        for k, v in params.items():
            s = s + f&quot;&#x27;{k}&#x27;: {v:.2f}, &quot;
        return s[0:-2]+&quot;}&quot;

</pre>
</details>
<details><summary><span class ='def signature'>def same_line_print(self,text):</span></summary>
<pre class ='def content'>        sys.stdout.write(f&quot;\r{text}          &quot;)
        sys.stdout.flush()

</pre>
</details>
<details><summary><span class ='def signature'>def random_variation(self, x):</span></summary>
<pre class ='def content'>        x_new = x.copy()
        for name in self.param_names:
            factor = 1 + random.uniform(-self.delta_x, self.delta_x)
            val = x[name] * factor
            x_new[name] = val
            if(name in self.bounds):
                minv, maxv = self.bounds[name]
                x_new[name] = max(min(x_new[name], maxv), minv)
        return x_new

</pre>
</details>
<details><summary><span class ='def signature'>def optimise(self, model,  verbose=False, tty=True):</span></summary>
<pre class ='def content'>        best_params = self.x_baseline.copy()
        best_model = self.build_fn(model, **best_params)
        best_model.write_nec()
        best_model.run_nec()
        result = self.cost_fn(best_model)
        best_cost = result[&#x27;cost&#x27;]
        best_info = result[&#x27;info&#x27;]
        stall_count = 0
        print(&quot;\nSTARTING optimiser. Press CTRL-C to stop&quot;)
        initial_message = f&quot;[] INITIAL: {best_info} with {self.format_params(best_params)}&quot;
        print(initial_message)

        try:
            for i in range(self.max_iter):
                test_params = self.random_variation(best_params)
                test_model = self.build_fn(model, **test_params)
                test_model.write_nec()
                test_model.run_nec()
                result = self.cost_fn(test_model)
                test_cost = result[&#x27;cost&#x27;]
                test_info = result[&#x27;info&#x27;]

                if test_cost &lt; best_cost:
                    best_cost = test_cost
                    best_params = test_params
                    best_info = test_info
                    stall_count = 0
                    if(not tty):
                        print(&quot;&quot;)
                    self.same_line_print(f&quot;[{i}] IMPROVED: {best_info} with {self.format_params(best_params)}&quot;)
                    print(&quot;&quot;)
                else:
                    stall_count += 1
                    if(tty):
                        self.same_line_print(f&quot;[{i}] {test_info}&quot;)
                    else:
                        sys.stdout.write(&quot;.&quot;)

                if stall_count &gt;= self.stall_limit:
                    self.delta_x /= 2
                    if(self.delta_x &lt; self.min_delta):
                        if(not tty):
                            print(&quot;&quot;)
                        self.same_line_print(f&quot;[{i}] Delta below minimum&quot;)
                        print(&quot;&quot;)
                        break
                    stall_count = 0
                    if(not tty):
                        print(&quot;&quot;)
                    self.same_line_print(f&quot;[{i}] STALLED: Reducing delta to {self.delta_x}&quot;)
                    print(&quot;&quot;)

        except KeyboardInterrupt:
            print(&quot;\nINTERRUPTED by user input&quot;)
            
        best_model = self.build_fn(model, **best_params)
        best_model.write_nec()
        best_model.run_nec()
        result = self.cost_fn(best_model)
        final_info = result[&#x27;info&#x27;]
        print(&quot;\nFINISHED optimising\n&quot;)
        print(&quot;# Optimiser Results (copy and paste into your antenna file for reference). \nNote that you can copy the information between the {} to paste in as your new starting parameters.)&quot;)
        print(&quot;# &quot;+ initial_message)
        print(f&quot;# []   FINAL: {final_info} with {self.format_params(best_params)}&quot;)
        
        return best_params, final_info
</pre>
</details>
</details>

<br><br><span style = 'font-size:0.8em;color:#666;border-top:1px solid #ddd; font-style:italic'>Made with Docu-lite v0.9.0 by Alan Robinson: github.com/G1OJS/docu-lite/</span></body>
